"""
For use by Illinois Experts staff.
Generates an updated thesaurus for use with VOSViewer.
- Compare thesaurus generated by shell script against an official list of internal authors, get the matches, the match ratio, and the line number of the name from the txt file.
- Returns matches which can be verified by user in IDE; approved matches update the original txt file.

Use case: 
- This script can be used in conjunction with the shell script when you have a visualization which will include hundreds of authors; this tool will speed up the process of identifying and adding "correct names" to the thesaurus file.

Requirements: fuzzywuzzy and python-Levenshtein packages, Microsoft Visual C++ tools
"""
import pandas as pd
from fuzzywuzzy import fuzz
from tkinter.filedialog import askopenfilename, asksaveasfilename


def access_internal_persons(ip_file: str) -> pd.DataFrame:
    """
    From an Excel file, create DataFrame containing internal persons; read in last name, first name, Pure ID
    :param ip_file: Str reference to Pure - Internal Persons file against which to validate the list of authors in csv_data.
    :return: DataFrame of internal_persons
    """
    df = pd.read_excel(ip_file, sheet_name="Persons (0)_1",
                       usecols=["2 Last, first name", "3 Name > Last name", "4 Name > First name", "18 ID",
                                "7.1 Organizations > Organizational unit[1]"], encoding='utf-8')
    columns_mapper = {'7.1 Organizations > Organizational unit[1]': 'unit'}
    df = df.rename(columns=columns_mapper)
    return df


def validate_internal_authors(author_list: list, internal_persons: pd.DataFrame, custom_ratio: int) -> list:
    """
    Read in list of 1+ reformatted authors (scope: 1 research output) and Internal Persons file.
    For each author in author_list,
        Use fuzzy matching to compare author with all persons in Internal Persons.
        Where a match is found, grab PureID and first Unit Affiliation; else, generate random ID and unit = np.nan.
    Add each author consecutively to new validated_authors list.

    NOTE: Beware of false matches where author names are very similar but represent different people. Set detailed_output=True for report.

    :param author_list: A list of tuples with 1+ authors ["Last, First", "Last, First"]
    :param internal_persons: Dataframe created by access_internal_persons()
    :param custom_ratio: 79 by default. Increase for a more strict matching test. Decrease to match more broadly.
    :return: matches_log as list()
    """
    matches_log = []
    strings_to_check = internal_persons["2 Last, first name"].to_list()
    for author in author_list:
        ratios = []
        for string in strings_to_check:
            if string == author:
                # Exact match
                ratios.append((string, 100, author_list.index(author)))
                break
            else:
                ratio = fuzz.ratio(string, author)
                if ratio > custom_ratio:
                    ratios.append((string, ratio, author_list.index(author)))
        if len(ratios) > 1:
            # If more than 1 person from Internal Persons file matched, return highest match
            ratios.sort(key=lambda x: x[1], reverse=True)
        if len(ratios) > 0:
            matches_log.append((author, ratios[0]))
    return matches_log


def review_update_persons(unstructured_persons_to_compare: list, internals: pd.DataFrame) -> list:
    """
    Take in the author names, send them to validate_internal_authors() to create matches log.
    For each match below 96 fuzzy score, prompt user to manually review and confirm whether match or not.
    If a match, update thesaurus list

    :param unstructured_persons_to_compare: Thesaurus list generated by shell script, based on plain-text names generated from an RIS file
    :param internals: Official internal authors' names from Pure (Illinois Experts) system
    :return: Updated thesaurus list
    """
    persons_to_compare = []

    for person in unstructured_persons_to_compare:
        auth = person[:-2]
        persons_to_compare.append(auth)

    matches = validate_internal_authors(persons_to_compare, internals, 82)
    for match in matches:
        source_name = match[0]
        authority_name = match[1][0]
        score = match[1][1]
        row = int(match[1][-1])
        current_value = unstructured_persons_to_compare[row]
        if score >= 96:
            unstructured_persons_to_compare[row] = current_value[:-1] + authority_name + '\n'
        else:
            print(match)
            confirm = input("Enter Y if it's a match. Enter any character if not a match.")
            if confirm in ["Y", "y", "Yes"]:
                unstructured_persons_to_compare[row] = current_value[:-1] + authority_name + '\n'
            else:
                continue
    return unstructured_persons_to_compare


if __name__ == '__main__':
    # Import internal persons df
    print("Choose the Excel file of internal persons downloaded from Pure.")
    inFileName = askopenfilename()
    ips = access_internal_persons(inFileName)

    # Import thesaurus
    print("Choose the thesaurus produced by the shell script.")
    tFileName = askopenfilename()
    t = open(tFileName, 'r', encoding='utf-8')
    print("Now processing... Hold please!")
    upc = t.readlines()
    print("The program will present you with two names. \nAt left, the author name as listed in the bibliometric data; at right, a possible internal match, their fuzzy match score, and their line number.\nIf they are a match, enter Y for yes.")
    compare = review_update_persons(upc, ips)

    # Create outfile - updated thesaurus
    print("Enter a name to save as the new thesaurus file with a .txt extension.")
    pFileName = asksaveasfilename()
    p = open(pFileName, 'w', encoding='utf-8')
    for person in compare:
        p.write(person)

    t.close()
    p.close()
